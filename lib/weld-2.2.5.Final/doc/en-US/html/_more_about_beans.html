<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 2. More about beans</title><link rel="stylesheet" href="css/seamframework.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Weld - CDI Reference Implementation"/><link rel="up" href="_beans.html" title="Part I. Beans"/><link rel="prev" href="_introduction.html" title="Chapter 1. Introduction"/><link rel="next" href="_jsf_web_application_example.html" title="Chapter 3. JSF web application example"/></head><body><p id="title"><a href="http://www.seamframework.org" class="site_href"><strong>SeamFramework.org</strong></a><a href="http://www.seamframework.org/Documentation" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="_introduction.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="_jsf_web_application_example.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_more_about_beans"/>Chapter 2. More about beans</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="_more_about_beans.html#_the_anatomy_of_a_bean">2.1. The anatomy of a bean</a></span></dt><dd><dl><dt><span class="section"><a href="_more_about_beans.html#_bean_types_qualifiers_and_dependency_injection">2.1.1. Bean types, qualifiers and dependency injection</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_scope">2.1.2. Scope</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_el_name">2.1.3. EL name</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_alternatives">2.1.4. Alternatives</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_interceptor_binding_types">2.1.5. Interceptor binding types</a></span></dt></dl></dd><dt><span class="section"><a href="_more_about_beans.html#_what_kinds_of_classes_are_beans">2.2. What kinds of classes are beans?</a></span></dt><dd><dl><dt><span class="section"><a href="_more_about_beans.html#_managed_beans">2.2.1. Managed beans</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_session_beans">2.2.2. Session beans</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_producer_methods">2.2.3. Producer methods</a></span></dt><dt><span class="section"><a href="_more_about_beans.html#_producer_fields">2.2.4. Producer fields</a></span></dt></dl></dd></dl></div>

<p>A bean is usually an application class that contains business logic. It
may be called directly from Java code, or it may be invoked via the
Unified EL. A bean may access transactional resources. Dependencies
between beans are managed automatically by the container. Most beans are
<span class="emphasis"><em>stateful</em></span> and <span class="emphasis"><em>contextual</em></span>. The lifecycle of a bean is managed by the
container.</p>
<p>Let’s back up a second. What does it really mean to be <span class="emphasis"><em>contextual</em></span>?
Since beans may be stateful, it matters <span class="emphasis"><em>which</em></span> bean instance I have.
Unlike a stateless component model (for example, stateless session
beans) or a singleton component model (such as servlets, or singleton
beans), different clients of a bean see the bean in different states.
The client-visible state depends upon which instance of the bean the
client has a reference to.</p>
<p>However, like a stateless or singleton model, but <span class="emphasis"><em>unlike</em></span> stateful
session beans, the client does not control the lifecycle of the instance
by explicitly creating and destroying it. Instead, the <span class="emphasis"><em>scope</em></span> of the
bean determines:</p>
<div class="itemizedlist"><ul><li>
the lifecycle of each instance of the bean and
</li><li>
which clients share a reference to a particular instance of the bean.
</li></ul></div>

<p>For a given thread in a CDI application, there may be an <span class="emphasis"><em>active
context</em></span> associated with the scope of the bean. This context may be
unique to the thread (for example, if the bean is request scoped), or it
may be shared with certain other threads (for example, if the bean is
session scoped) or even all other threads (if it is application scoped).</p>
<p>Clients (for example, other beans) executing in the same context will
see the same instance of the bean. But clients in a different context
may see a different instance (depending on the relationship between the
contexts).</p>
<p>One great advantage of the contextual model is that it allows stateful
beans to be treated like services! The client need not concern itself
with managing the lifecycle of the bean it’s using, <span class="emphasis"><em>nor does it even
need to know what that lifecycle is.</em></span> Beans interact by passing
messages, and the bean implementations define the lifecycle of their own
state. The beans are loosely coupled because:</p>
<div class="itemizedlist"><ul><li>
they interact via well-defined public APIs
</li><li>
their lifecycles are completely decoupled
</li></ul></div>

<p>We can replace one bean with another different bean that implements the
same interface and has a different lifecycle (a different scope) without
affecting the other bean implementation. In fact, CDI defines a simple
facility for overriding bean implementations at deployment time, as we
will see in <a href="_dependency_injection_and_programmatic_lookup.html#alternatives" title="4.7. Alternatives">Section 4.7, “Alternatives”</a>.</p>
<p>Note that not all clients of a bean are beans themselves. Other objects
such as servlets or message-driven beans—which are by nature not
injectable, contextual objects—may also obtain references to beans by
injection.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_the_anatomy_of_a_bean"/>2.1. The anatomy of a bean</h2></div></div></div>

<p>Enough hand-waving. More formally, the anatomy of a bean, according to
the spec:</p>
<div class="blockquote"><blockquote class="blockquote">
  
<p>A bean comprises the following attributes:</p>
<div class="itemizedlist"><ul><li>
A (nonempty) set of bean types
</li><li>
A (nonempty) set of qualifiers
</li><li>
A scope
</li><li>
Optionally, a bean EL name
</li><li>
A set of interceptor bindings
</li><li>
A bean implementation
</li></ul></div>

<p>Furthermore, a bean may or may not be an alternative.</p>
</blockquote></div>

<p>Let’s see what all this new terminology means.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_bean_types_qualifiers_and_dependency_injection"/>2.1.1. Bean types, qualifiers and dependency injection</h3></div></div></div>

<p>Beans usually acquire references to other beans via dependency
injection. Any injected attribute specifies a "contract" that must be
satisfied by the bean to be injected. The contract is:</p>
<div class="itemizedlist"><ul><li>
a bean type, together with
</li><li>
a set of qualifiers.
</li></ul></div>

<p>A bean type is a user-defined class or interface; a type that is
client-visible. If the bean is an EJB session bean, the bean type is the
<code class="literal">@Local</code> interface or bean-class local view. A bean may have multiple
bean types. For example, the following bean has four bean types:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">BookShop</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Business</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Shop</span><span class="java_operator">&lt;</span><span class="java_type">Book</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>The bean types are <code class="literal">BookShop</code>, <code class="literal">Business</code> and <code class="literal">Shop&lt;Book&gt;</code>, as well as
the implicit type <code class="literal">java.lang.Object</code>. (Notice that a parameterized type
is a legal bean type).</p>
<p>Meanwhile, this session bean has only the local interfaces <code class="literal">BookShop</code>,
<code class="literal">Auditable</code> and <code class="literal">java.lang.Object</code> as bean types, since the bean class,
<code class="literal">BookShopBean</code> is not a client-visible type.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Stateful</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">BookShopBean</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Business</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">BookShop</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Auditable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>The bean types of a session bean include local interfaces and the bean
class local view (if any). EJB remote interfaces are not considered bean
types of a session bean. You can’t inject an EJB using its remote
interface unless you define a <span class="emphasis"><em>resource</em></span>, which we’ll meet in
<a href="_java_ee_component_environment_resources.html" title="Chapter 14. Java EE component environment resources">Chapter 14, <i xmlns:xlink="http://www.w3.org/1999/xlink">Java EE component environment resources</i></a>.</p>
</div>

<p>Bean types may be restricted to an explicit set by annotating the bean
with the <code class="literal">@Typed</code> annotation and listing the classes that should be bean
types. For instance, the bean types of this bean have been restricted to
<code class="literal">Shop&lt;Book&gt;</code>, together with <code class="literal">java.lang.Object</code>:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Typed</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Shop</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">BookShop</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Business</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Shop</span><span class="java_operator">&lt;</span><span class="java_type">Book</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>Sometimes, a bean type alone does not provide enough information for the
container to know which bean to inject. For instance, suppose we have
two implementations of the <code class="literal">PaymentProcessor</code> interface:
<code class="literal">CreditCardPaymentProcessor</code> and <code class="literal">DebitPaymentProcessor</code>. Injecting a
field of type <code class="literal">PaymentProcessor</code> introduces an ambiguous condition. In
these cases, the client must specify some additional quality of the
implementation it is interested in. We model this kind of "quality"
using a qualifier.</p>
<p>A qualifier is a user-defined annotation that is itself annotated
<code class="literal">@Qualifier</code>. A qualifier annotation is an extension of the type system.
It lets us disambiguate a type without having to fall back to
string-based names. Here’s an example of a qualifier annotation:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Qualifier</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Target</span><span class="java_separator">({</span><span class="java_plain">TYPE</span><span class="java_separator">,</span><span class="java_plain">&nbsp;METHOD</span><span class="java_separator">,</span><span class="java_plain">&nbsp;PARAMETER</span><span class="java_separator">,</span><span class="java_plain">&nbsp;FIELD</span><span class="java_separator">})</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Retention</span><span class="java_separator">(</span><span class="java_plain">RUNTIME</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;@</span><span class="java_keyword">interface</span><span class="java_plain">&nbsp;</span><span class="java_type">CreditCard</span><span class="java_plain">&nbsp;</span><span class="java_separator">{}</span></pre>

<p>You may not be used to seeing the definition of an annotation. In fact,
this might be the first time you’ve encountered one. With CDI,
annotation definitions will become a familiar artifact as you’ll be
creating them from time to time.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Pay attention to the names of the built-in annotations in CDI and EJB.
You’ll notice that they are often adjectives. We encourage you to follow
this convention when creating your custom annotations, since they serve
to describe the behaviors and roles of the class.</p>
</div>

<p>Now that we have defined a qualifier annotation, we can use it to
disambiguate an injection point. The following injection point has the
bean type <code class="literal">PaymentProcessor</code> and qualifier <code class="literal">@CreditCard</code>:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Inject</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">CreditCard</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">PaymentProcessor</span><!-- <br/> --><span class="java_plain">&nbsp;paymentProcessor</span></pre>

<p>For each injection point, the container searches for a bean which
satisfies the contract, one which has the bean type and all the
qualifiers. If it finds exactly one matching bean, it injects an
instance of that bean. If it doesn’t, it reports an error to the user.</p>
<p>How do we specify that qualifiers of a bean? By annotating the bean
class, of course! The following bean has the qualifier <code class="literal">@CreditCard</code> and
implements the bean type <code class="literal">PaymentProcessor</code>. Therefore, it satisfies our
qualified injection point:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">CreditCard</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">CreditCardPaymentProcessor</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">PaymentProcessor</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>If a bean or an injection point does not explicitly specify a qualifier,
it has the default qualifier, <code class="literal">@Default</code>.</p>
</div>

<p>That’s not quite the end of the story. CDI also defines a simple
<span class="emphasis"><em>resolution rule</em></span> that helps the container decide what to do if there is
more than one bean that satisfies a particular contract. We’ll get into
the details in <a href="_dependency_injection_and_programmatic_lookup.html" title="Chapter 4. Dependency injection and programmatic lookup">Chapter 4, <i xmlns:xlink="http://www.w3.org/1999/xlink">Dependency injection and programmatic lookup</i></a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_scope"/>2.1.2. Scope</h3></div></div></div>

<p>The <span class="emphasis"><em>scope</em></span> of a bean defines the lifecycle and visibility of its
instances. The CDI context model is extensible, accommodating arbitrary
scopes. However, certain important scopes are built into the
specification, and provided by the container. Each scope is represented
by an annotation type.</p>
<p>For example, any web application may have <span class="emphasis"><em>session scoped</em></span> bean:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">SessionScoped</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">ShoppingCart</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>An instance of a session-scoped bean is bound to a user session and is
shared by all requests that execute in the context of that session.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Keep in mind that once a bean is bound to a context, it remains in that
context until the context is destroyed. There is no way to manually
remove a bean from a context. If you don’t want the bean to sit in the
session indefinitely, consider using another scope with a shorted
lifespan, such as the request or conversation scope.</p>
</div>

<p>If a scope is not explicitly specified, then the bean belongs to a
special scope called the <span class="emphasis"><em>dependent pseudo-scope</em></span>. Beans with this scope
live to serve the object into which they were injected, which means
their lifecycle is bound to the lifecycle of that object.</p>
<p>We’ll talk more about scopes in <a href="_scopes_and_contexts.html" title="Chapter 5. Scopes and contexts">Chapter 5, <i xmlns:xlink="http://www.w3.org/1999/xlink">Scopes and contexts</i></a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_el_name"/>2.1.3. EL name</h3></div></div></div>

<p>If you want to reference a bean in non-Java code that supports Unified
EL expressions, for example, in a JSP or JSF page, you must assign the
bean an <span class="emphasis"><em>EL name</em></span>.</p>
<p>The EL name is specified using the <code class="literal">@Named</code> annotation, as shown here:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">SessionScoped</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Named</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;cart&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">ShoppingCart</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>Now we can easily use the bean in any JSF or JSP page:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">h:dataTable</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;#{cart.lineItems}&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">var</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;item&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">h:dataTable</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>The <code class="literal">@Named</code> annotation is not what makes the class a bean. Most classes
in a bean archive are already recognized as beans. The <code class="literal">@Named</code>
annotation just makes it possible to reference the bean from the EL,
most commonly from a JSF view.</p>
</div>

<p>We can let CDI choose a name for us by leaving off the value of the
<code class="literal">@Named</code> annotation:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">SessionScoped</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Named</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">ShoppingCart</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>The name defaults to the unqualified class name, decapitalized; in this
case, <code class="literal">shoppingCart</code>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_alternatives"/>2.1.4. Alternatives</h3></div></div></div>

<p>We’ve already seen how qualifiers let us choose between multiple
implementations of an interface at development time. But sometimes we
have an interface (or other bean type) whose implementation varies
depending upon the deployment environment. For example, we may want to
use a mock implementation in a testing environment. An <span class="emphasis"><em>alternative</em></span> may
be declared by annotating the bean class with the <code class="literal">@Alternative</code>
annotation.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Alternative</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">MockPaymentProcessor</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">PaymentProcessorImpl</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>We normally annotate a bean <code class="literal">@Alternative</code> only when there is some other
implementation of an interface it implements (or of any of its bean
types). We can choose between alternatives at deployment time by
<span class="emphasis"><em>selecting</em></span> an alternative in the CDI deployment descriptor
<code class="literal">META-INF/beans.xml</code> of the jar or Java EE module that uses it.
Different modules can specify that they use different alternatives.</p>
<p>We cover alternatives in more detail in <a href="_dependency_injection_and_programmatic_lookup.html#alternatives" title="4.7. Alternatives">Section 4.7, “Alternatives”</a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_interceptor_binding_types"/>2.1.5. Interceptor binding types</h3></div></div></div>

<p>You might be familiar with the use of interceptors in EJB 3. Since Java
EE 6, this functionality has been generalized to work with other managed
beans. That’s right, you no longer have to make your bean an EJB just to
intercept its methods. Holler. So what does CDI have to offer above and
beyond that? Well, quite a lot actually. Let’s cover some background.</p>
<p>The way that interceptors were defined in Java EE 5 was
counter-intuitive. You were required to specify the <span class="emphasis"><em>implementation</em></span> of
the interceptor directly on the <span class="emphasis"><em>implementation</em></span> of the EJB, either in
the <code class="literal">@Interceptors</code> annotation or in the XML descriptor. You might as
well just put the interceptor code <span class="emphasis"><em>in</em></span> the implementation! Second, the
order in which the interceptors are applied is taken from the order in
which they are declared in the annotation or the XML descriptor. Perhaps
this isn’t so bad if you’re applying the interceptors to a single bean.
But, if you are applying them repeatedly, then there’s a good chance
that you’ll inadvertently define a different order for different beans.
Now that’s a problem.</p>
<p>CDI provides a new approach to binding interceptors to beans that
introduces a level of indirection (and thus control). We must define an
<span class="emphasis"><em>interceptor binding type</em></span> to describe the behavior implemented by the
interceptor.</p>
<p>An interceptor binding type is a user-defined annotation that is itself
annotated <code class="literal">@InterceptorBinding</code>. It lets us bind interceptor classes to
bean classes with no direct dependency between the two classes.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">InterceptorBinding</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Inherited</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Target</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;TYPE</span><span class="java_separator">,</span><span class="java_plain">&nbsp;METHOD&nbsp;</span><span class="java_separator">})</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Retention</span><span class="java_separator">(</span><span class="java_plain">RUNTIME</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;@</span><span class="java_keyword">interface</span><span class="java_plain">&nbsp;</span><span class="java_type">Transactional</span><span class="java_plain">&nbsp;</span><span class="java_separator">{}</span></pre>

<p>The interceptor that implements transaction management declares this
annotation:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Transactional</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Interceptor</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">TransactionInterceptor</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>We can apply the interceptor to a bean by annotating the bean class with
the same interceptor binding type:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">SessionScoped</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Transactional</span>
<!--  --><br/><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">ShoppingCart</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre>

<p>Notice that <code class="literal">ShoppingCart</code> and <code class="literal">TransactionInterceptor</code> don’t know
anything about each other.</p>
<p>Interceptors are deployment-specific. (We don’t need a
<code class="literal">TransactionInterceptor</code> in our unit tests!) By default, an interceptor
is disabled. We can enable an interceptor using the CDI deployment
descriptor <code class="literal">META-INF/beans.xml</code> of the jar or Java EE module. This is
also where we specify the interceptor ordering.</p>
<p>We’ll discuss interceptors, and their cousins, decorators, in <a href="_interceptors.html" title="Chapter 9. Interceptors">Chapter 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Interceptors</i></a> and <a href="_decorators.html" title="Chapter 10. Decorators">Chapter 10, <i xmlns:xlink="http://www.w3.org/1999/xlink">Decorators</i></a>.</p>
</div>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_what_kinds_of_classes_are_beans"/>2.2. What kinds of classes are beans?</h2></div></div></div>

<p>We’ve already seen two types of beans: JavaBeans and EJB session beans.
Is that the whole story? Actually, it’s just the beginning. Let’s
explore the various kinds of beans that CDI implementations must support
out-of-the-box.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_managed_beans"/>2.2.1. Managed beans</h3></div></div></div>

<p>A managed bean is a Java class. The basic lifecycle and semantics of a
managed bean are defined by the Managed Beans specification. You can
explicitly declare a managed bean by annotating the bean class
<code class="literal">@ManagedBean</code>, but in CDI you don’t need to. According to the
specification, the CDI container treats any class that satisfies the
following conditions as a managed bean:</p>
<div class="itemizedlist"><ul><li>
It is not a non-static inner class.
</li><li>
It is a concrete class, or is annotated <code class="literal">@Decorator</code>.
</li><li>
It is not annotated with an EJB component-defining annotation or
declared as an EJB bean class in <code class="literal">ejb-jar.xml</code>.
</li><li>
It does not implement <code class="literal">javax.enterprise.inject.spi.Extension</code>.
</li><li>
<p>It has an appropriate constructor—either:</p>
<div class="itemizedlist"><ul><li>
the class has a constructor with no parameters, or
</li><li>
the class declares a constructor annotated <code class="literal">@Inject</code>.
</li></ul></div>

</li></ul></div>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>According to this definition, JPA entities are technically managed
beans. However, entities have their own special lifecycle, state and
identity model and are usually instantiated by JPA or using <code class="literal">new</code>.
Therefore we don’t recommend directly injecting an entity class. We
especially recommend against assigning a scope other than <code class="literal">@Dependent</code>
to an entity class, since JPA is not able to persist injected CDI
proxies.</p>
</div>

<p>The unrestricted set of bean types for a managed bean contains the bean
class, every superclass and all interfaces it implements directly or
indirectly.</p>
<p>If a managed bean has a public field, it must have the default scope
<code class="literal">@Dependent</code>.</p>
<p>Managed beans support the <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> lifecycle
callbacks.</p>
<p>Session beans are also, technically, managed beans. However, since they
have their own special lifecycle and take advantage of additional
enterprise services, the CDI specification considers them to be a
different kind of bean.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_session_beans"/>2.2.2. Session beans</h3></div></div></div>

<p>Session beans belong to the EJB specification. They have a special
lifecycle, state management and concurrency model that is different to
other managed beans and non-managed Java objects. But session beans
participate in CDI just like any other bean. You can inject one session
bean into another session bean, a managed bean into a session bean, a
session bean into a managed bean, have a managed bean observe an event
raised by a session bean, and so on.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Message-driven and entity beans are by nature non-contextual objects and
may not be injected into other objects. However, message-driven beans
can take advantage of some CDI functionality, such as dependency
injection, interceptors and decorators. In fact, CDI will perform
injection into any session or message-driven bean, even those which are
not contextual instances.</p>
</div>

<p>The unrestricted set of bean types for a session bean contains all local
interfaces of the bean and their superinterfaces. If the session bean
has a bean class local view, the unrestricted set of bean types contains
the bean class and all superclasses. In addition, <code class="literal">java.lang.Object</code> is
a bean type of every session bean. But remote interfaces are <span class="emphasis"><em>not</em></span>
included in the set of bean types.</p>
<p>There’s no reason to explicitly declare the scope of a stateless session
bean or singleton session bean. The EJB container controls the lifecycle
of these beans, according to the semantics of the <code class="literal">@Stateless</code> or
<code class="literal">@Singleton</code> declaration. On the other hand, a stateful session bean may
have any scope.</p>
<p>Stateful session beans may define a <span class="emphasis"><em>remove method</em></span>, annotated
<code class="literal">@Remove</code>, that is used by the application to indicate that an instance
should be destroyed. However, for a contextual instance of the bean—an
instance under the control of CDI—this method may only be called by the
application if the bean has scope <code class="literal">@Dependent</code>. For beans with other
scopes, the application must let the container destroy the bean.</p>
<p>So, when should we use a session bean instead of a plain managed bean?
Whenever we need the advanced enterprise services offered by EJB, such
as:</p>
<div class="itemizedlist"><ul><li>
method-level transaction management and security,
</li><li>
concurrency management,
</li><li>
instance-level passivation for stateful session beans and
instance-pooling for stateless session beans,
</li><li>
remote or web service invocation, or
</li><li>
timers and asynchronous methods,
</li></ul></div>

<p>When we don’t need any of these things, an ordinary managed bean will
serve just fine.</p>
<p>Many beans (including any <code class="literal">@SessionScoped</code> or <code class="literal">@ApplicationScoped</code>
beans) are available for concurrent access. Therefore, the concurrency
management provided by EJB 3.2 is especially useful. Most session and
application scoped beans should be EJBs.</p>
<p>Beans which hold references to heavy-weight resources, or hold a lot of
internal state benefit from the advanced container-managed lifecycle
defined by the EJB stateless/stateful/singleton model, with its support
for passivation and instance pooling.</p>
<p>Finally, it’s usually obvious when method-level transaction management,
method-level security, timers, remote methods or asynchronous methods
are needed.</p>
<p>The point we’re trying to make is: use a session bean when you need the
services it provides, not just because you want to use dependency
injection, lifecycle management, or interceptors. Java EE 7 provides a
graduated programming model. It’s usually easy to start with an ordinary
managed bean, and later turn it into an EJB just by adding one of the
following annotations: <code class="literal">@Stateless</code>, <code class="literal">@Stateful</code> or <code class="literal">@Singleton</code>.</p>
<p>On the other hand, don’t be scared to use session beans just because
you’ve heard your friends say they’re "heavyweight". It’s nothing more
than superstition to think that something is "heavier" just because it’s
hosted natively within the Java EE container, instead of by a
proprietary bean container or dependency injection framework that runs
as an additional layer of obfuscation. And as a general principle, you
should be skeptical of folks who use vaguely defined terminology like
"heavyweight".</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_producer_methods"/>2.2.3. Producer methods</h3></div></div></div>

<p>Not everything that needs to be injected can be boiled down to a bean
class instantiated by the container using <code class="literal">new</code>. There are plenty of
cases where we need additional control. What if we need to decide at
runtime which implementation of a type to instantiate and inject? What
if we need to inject an object that is obtained by querying a service or
transactional resource, for example by executing a JPA query?</p>
<p>A <span class="emphasis"><em>producer method</em></span> is a method that acts as a source of bean instances.
The method declaration itself describes the bean and the container
invokes the method to obtain an instance of the bean when no instance
exists in the specified context. A producer method lets the application
take full control of the bean instantiation process.</p>
<p>A producer method is declared by annotating a method of a bean class
with the <code class="literal">@Produces</code> annotation.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">import</span><!-- <br/> --><span class="java_plain">&nbsp;javax</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">enterprise</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">inject</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_type">Produces</span><!-- <br/> --><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">ApplicationScoped</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">RandomNumberGenerator</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;java</span><span class="java_separator">.</span><span class="java_plain">util</span><span class="java_separator">.</span><span class="java_type">Random</span><span class="java_plain">&nbsp;random&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;java</span><span class="java_separator">.</span><span class="java_plain">util</span><span class="java_separator">.</span><span class="java_type">Random</span><span class="java_separator">(</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">currentTimeMillis</span><span class="java_separator">());</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Produces</span><span class="java_plain">&nbsp;@</span><span class="java_type">Named</span><span class="java_plain">&nbsp;@</span><span class="java_type">Random</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;getRandomNumber</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;random</span><span class="java_separator">.</span><span class="java_plain">nextInt</span><span class="java_separator">(</span><span class="java_literal">100</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>We can’t write a bean class that is itself a random number. But we can
certainly write a method that returns a random number. By making the
method a producer method, we allow the return value of the method—in
this case an <code class="literal">Integer</code>—to be injected. We can even specify a
qualifier—in this case <code class="literal">@Random</code>, a scope—which in this case defaults to
<code class="literal">@Dependent</code>, and an EL name—which in this case defaults to
<code class="literal">randomNumber</code> according to the JavaBeans property name convention. Now
we can get a random number anywhere:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Inject</span><!-- <br/> --><span class="java_plain">&nbsp;@</span><!-- <br/> --><span class="java_type">Random</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">int</span><!-- <br/> --><span class="java_plain">&nbsp;randomNumber</span><!-- <br/> --><span class="java_separator">;</span></pre>

<p>Even in a Unified EL expression:</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">p</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">Your&nbsp;raffle&nbsp;number&nbsp;is&nbsp;#{randomNumber}.</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">p</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre>

<p>A producer method must be a non-abstract method of a managed bean class
or session bean class. A producer method may be either static or
non-static. If the bean is a session bean, the producer method must be
either a business method of the EJB or a static method of the bean
class.</p>
<p>The bean types of a producer method depend upon the method return type:</p>
<div class="itemizedlist"><ul><li>
If the return type is an interface, the unrestricted set of bean types
contains the return type, all interfaces it extends directly or
indirectly and <code class="literal">java.lang.Object</code>.
</li><li>
If a return type is primitive or is a Java array type, the
unrestricted set of bean types contains exactly two types: the method
return type and <code class="literal">java.lang.Object</code>.
</li><li>
If the return type is a class, the unrestricted set of bean types
contains the return type, every superclass and all interfaces it
implements directly or indirectly.
</li></ul></div>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Producer methods and fields may have a primitive bean type. For the
purpose of resolving dependencies, primitive types are considered to be
identical to their corresponding wrapper types in <code class="literal">java.lang</code>.</p>
</div>

<p>If the producer method has method parameters, the container will look
for a bean that satisfies the type and qualifiers of each parameter and
pass it to the method automatically—another form of dependency
injection.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Produces</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Set</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_type">Roles</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;getRoles</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_plain">&nbsp;user</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;user</span><span class="java_separator">.</span><span class="java_plain">getRoles</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>We’ll talk much more about producer methods in <a href="producer_methods.html" title="Chapter 8. Producer methods">Chapter 8, <i xmlns:xlink="http://www.w3.org/1999/xlink">Producer methods</i></a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_producer_fields"/>2.2.4. Producer fields</h3></div></div></div>

<p>A <span class="emphasis"><em>producer field</em></span> is a simpler alternative to a producer method. A
producer field is declared by annotating a field of a bean class with
the <code class="literal">@Produces</code> annotation—the same annotation used for producer
methods.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">import</span><!-- <br/> --><span class="java_plain">&nbsp;javax</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">enterprise</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">inject</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_type">Produces</span><!-- <br/> --><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Shop</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Produces</span><span class="java_plain">&nbsp;</span><span class="java_type">PaymentProcessor</span><span class="java_plain">&nbsp;paymentProcessor&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">....;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Produces</span><span class="java_plain">&nbsp;@</span><span class="java_type">Catalog</span><span class="java_plain">&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;</span><span class="java_type">Product</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;products&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">....;</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>The rules for determining the bean types of a producer field parallel
the rules for producer methods.</p>
<p>A producer field is really just a shortcut that lets us avoid writing a
useless getter method. However, in addition to convenience, producer
fields serve a specific purpose as an adaptor for Java EE component
environment injection, but to learn more about that, you’ll have to wait
until <a href="_java_ee_component_environment_resources.html" title="Chapter 14. Java EE component environment resources">Chapter 14, <i xmlns:xlink="http://www.w3.org/1999/xlink">Java EE component environment resources</i></a>. Because we can’t wait to get
to work on some examples.</p>
</div>
</div>
</div><ul class="docnav"><li class="previous"><a accesskey="p" href="_introduction.html"><strong>Prev</strong>Chapter 1. Introduction</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="_jsf_web_application_example.html"><strong>Next</strong>Chapter 3. JSF web application example</a></li></ul></body></html>