<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Appendix A. Integrating Weld into other environments</title><link rel="stylesheet" href="css/seamframework.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Weld - CDI Reference Implementation"/><link rel="up" href="_weld_reference_guide.html" title="Part V. Weld Reference Guide"/><link rel="prev" href="_configuration.html" title="Chapter 20. Configuration"/></head><body><p id="title"><a href="http://www.seamframework.org" class="site_href"><strong>SeamFramework.org</strong></a><a href="http://www.seamframework.org/Documentation" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="_configuration.html"><strong>Prev</strong></a></li><li class="next"/></ul><div class="appendix" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_integrating_weld_into_other_environments"/>Appendix A. Integrating Weld into other environments</h2></div></div></div>

<p>If you want to use Weld in another environment, you will need to provide
certain information to Weld via the integration SPI. In this Appendix we
will briefly discuss the steps needed.</p>
<p>If you are upgrading existing Weld integration to work with Weld 2, see
this
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://community.jboss.org/wiki/WeldIntegratorGuide-ChangesForWeld20">migration
document</a>.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>If you just want to use managed beans, and not take advantage of
enterprise services (EE resource injection, CDI injection into EE
component classes, transactional events, support for CDI services in
EJBs) and non-flat deployments, then the generic servlet support
provided by the "Weld: Servlets" extension will be sufficient, and will
work in any container supporting the Servlet API.</p>
</div>

<p>All SPIs and APIs described have extensive JavaDoc, which spell out the
detailed contract between the container and Weld.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_the_weld_spi"/>A.1. The Weld SPI</h2></div></div></div>

<p>The Weld SPI is located in the <code class="literal">weld-spi</code> module, and packaged as
<code class="literal">weld-spi.jar</code>. Some SPIs are optional, and should only be implemented
if you need to override the default behavior; others are required.</p>
<p>All interfaces in the SPI support the decorator pattern and provide a
<code class="literal">Forwarding</code> class located in the <code class="literal">helpers</code> sub package. Additional,
commonly used, utility classes, and standard implementations are also
located in the <code class="literal">helpers</code> sub package.</p>
<p>Weld supports multiple environments. An environment is defined by an
implementation of the <code class="literal">Environment</code> interface. A number of standard
environments are built in, and described by the <code class="literal">Environments</code>
enumeration. Different environments require different services to be
present (for example a Servlet container doesn’t require transaction,
EJB or JPA services). By default an EE environment is assumed, but you
can adjust the environment by calling <code class="literal">bootstrap.setEnvironment()</code>.</p>
<p>Weld uses services to communicate with its environment. A service is a
java class that implements the <code class="literal">org.jboss.weld.bootstrap.api.Service</code>
interface and is explicitly registered. A service may be BDA-specific or
may be shared across the entire application.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Service</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;cleanup</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>Certain services are only used at bootstrap and need to be cleaned up
afterwards in order not to consume memory. A service that implements the
specialized <code class="literal">org.jboss.weld.bootstrap.api.BootstrapService</code> interface
receives a <code class="literal">cleanupAfterBoot()</code> method invocation once Weld
initialization is finished but before the deployment is put into
service.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">BootstrapService</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">extends</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Service</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;cleanupAfterBoot</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>Weld uses a generic-typed service registry to allow services to be
registered. All services implement the <code class="literal">Service</code> interface. The service
registry allows services to be added and retrieved.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_deployment_structure"/>A.1.1. Deployment structure</h3></div></div></div>

<p>An application is often comprised of a number of modules. For example, a
Java EE deployment may contain a number of EJB modules (containing
business logic) and war modules (containing the user interface). A
container may enforce certain <span class="emphasis"><em>accessibility</em></span> rules which limit the
visibility of classes between modules. CDI allows these same rules to
apply to bean and observer method resolution. As the accessibility rules
vary between containers, Weld requires the container to <span class="emphasis"><em>describe</em></span> the
deployment structure, via the <code class="literal">Deployment</code> SPI.</p>
<p>The CDI specification discusses <span class="emphasis"><em>Bean Archives</em></span> (BAs)—archives which are
marked as containing beans which should be deployed to the CDI
container, and made available for injection and resolution. Weld reuses
this description and uses <span class="emphasis"><em>Bean Deployment Archives (BDA)</em></span> in its
deployment structure SPI.</p>
<p>Each deployment exposes the containing BDAs that form a graph. A node in
the graph represents a BDA. Directed edges between nodes designate
visibility. Visibility is not transitive (i.e. a bean from BDA A can
only see beans in BDAs with which A is directly connected by a properly
oriented edge).</p>
<p>To describe the deployment structure to Weld, the container should
provide an implementation of <code class="literal">Deployment</code>.
<code class="literal">Deployment.getBeanDeploymentArchives()</code> allows Weld to discover the
modules which make up the application. The CDI specification also allows
beans to be specified programmatically as part of the bean deployment.
These beans may, or may not, be in an existing BDA. For this reason,
Weld will call <code class="literal">Deployment.loadBeanDeploymentArchive(Class clazz)</code> for
each programmatically described bean.</p>
<p>As programmatically described beans may result in additional BDAs being
added to the graph, Weld will discover the BDA structure every time an
unknown BDA is returned by <code class="literal">Deployment.loadBeanDeploymentArchive</code>.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>In a strict container, each BDA might have to explicitly specify which
other BDAs it can access. However many containers will allow an easy
mechanism to make BDAs bi-directionally accessible (such as a library
directory). In this case, it is allowable (and reasonable) to describe
all such archives as a single, <span class="emphasis"><em>virtual</em></span> <code class="literal">BeanDeploymentArchive</code>.</p>
<p>A container, might, for example, use a flat accessibility structure for
the application. In this case, a single <code class="literal">BeanDeploymentArchive</code> would be
attached to the <code class="literal">Deployment</code>.</p>
</div>

<p><code class="literal">BeanDeploymentArchive</code> provides three methods which allow it’s contents
to be discovered by Weld—<code class="literal">BeanDeploymentArchive.getBeanClasses()</code> must
return all the classes in the BDA, <code class="literal">BeanDeploymentArchive.getBeansXml()</code>
must return a data structure representing the <code class="literal">beans.xml</code> deployment
descriptor for the archive, and <code class="literal">BeanDeploymentArchive.getEjbs()</code> must
provide an EJB descriptor for every EJB in the BDA, or an empty list if
it is not an EJB archive.</p>
<p>To aid container integrator, Weld provides a built-in <code class="literal">beans.xml</code>
parser. To parse a <code class="literal">beans.xml</code> into the data-structure required by
<code class="literal">BeanDeploymentArchive</code>, the container should call
<code class="literal">Bootstrap.parse(URL)</code>. Weld can also parse multiple <code class="literal">beans.xml</code> files,
merging them to become a single data-structure. This can be achieved by
calling <code class="literal">Bootstrap.parse(Iterable&lt;URL&gt;)</code>.</p>
<p>When multiple <code class="literal">beans.xml</code> files are merged, Weld keeps duplicate enabled
entries (interceptors, decorators or alternatives). This may cause
validation problems when multiple physical archives which define an
overlapping enabled entries are merged. A version of the
<code class="literal">Bootstrap.parse()</code> method that provides control over whether duplicate
enabled entries are remove or not is provided:
<code class="literal">Bootstrap.parse(Iterable&lt;URL&gt; urls, boolean removeDuplicates)</code>.</p>
<p>BDA X may also reference another BDA Y whose beans can be resolved by,
and injected into, any bean in BDA X. These are the accessible BDAs, and
every BDA that is directly accessible by BDA X should be returned. A BDA
will also have BDAs which are accessible transitively, and the
transitive closure of the sub-graph of BDA X describes all the beans
resolvable by BDA X.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>In practice, you can regard the deployment structure represented by
<code class="literal">Deployment</code>, and the virtual BDA graph as a mirror of the classloader
structure for a deployment. If a class can from BDA X can be loaded by
another in BDA Y, it is accessible, and therefore BDA Y’s accessible
BDAs should include BDA X.</p>
</div>

<p>To specify the directly accessible BDAs, the container should provide an
implementation of <code class="literal">BeanDeploymentArchive.getBeanDeploymentArchives()</code>.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Weld allows the container to describe a circular graph, and will convert
a graph to a tree as part of the deployment process.</p>
</div>

<p>Certain services are provided for the whole deployment, whilst some are
provided per-BDA. BDA services are provided using
<code class="literal">BeanDeploymentArchive.getServices()</code> and only apply to the BDA on which
they are provided.</p>
<p>The contract for <code class="literal">Deployment</code> requires the container to specify the
portable extensions (see chapter 12 of the CDI specification) which
should be loaded by the application. To aid the container integrator,
Weld provides the method <code class="literal">Bootstrap.loadExtensions(ClassLoader)</code> which
will load the extensions for the specified classloader.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_ejb_descriptors"/>A.1.2. EJB descriptors</h3></div></div></div>

<p>Weld delegates EJB 3 bean discovery to the container so that it doesn’t
duplicate the work done by the EJB container, and respects any
vendor-extensions to the EJB definition.</p>
<p>The <code class="literal">EjbDescriptor</code> should return the relevant metadata as defined in
the EJB specification. Each business interface of a session bean should
be described using a <code class="literal">BusinessInterfaceDescriptor</code>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_ee_resource_injection_and_resolution_services"/>A.1.3. EE resource injection and resolution services</h3></div></div></div>

<p>All the EE resource services are per-BDA services, and may be provided
using one of two methods. Which method to use is at the discretion of
the integrator.</p>
<p>The integrator may choose to provide all EE resource injection services
themselves, using another library or framework. In this case the
integrator should use the <code class="literal">EE</code> environment, and implement the <a href="_integrating_weld_into_other_environments.html#_injection_services" title="A.1.9. Injection Services">Section A.1.9, “Injection Services”</a> SPI.</p>
<p>Alternatively, the integrator may choose to use CDI to provide EE
resource injection. In this case, the <code class="literal">EE_INJECT</code> environment should be
used, and the integrator should implement the <a href="_integrating_weld_into_other_environments.html#_ejb_services" title="A.1.4. EJB services">Section A.1.4, “EJB services”</a>, <a href="_integrating_weld_into_other_environments.html#_resource_services" title="A.1.7. Resource Services">Section A.1.7, “Resource Services”</a>
and <a href="_integrating_weld_into_other_environments.html#_jpa_services" title="A.1.5. JPA services">Section A.1.5, “JPA services”</a>.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2>
<p>CDI only provides annotation-based EE resource injection; if you wish to
provide deployment descriptor (e.g. <code class="literal">ejb-jar.xml</code>) injection, you must
use <a href="_integrating_weld_into_other_environments.html#_injection_services" title="A.1.9. Injection Services">Section A.1.9, “Injection Services”</a>.</p>
</div>

<p>If the container performs EE resource injection, the injected resources
must be serializable. If EE resource injection is provided by Weld, the
resolved resource must be serializable.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2>
<p>If you use a non-EE environment then you may implement any of the EE
service SPIs, and Weld will provide the associated functionality. There
is no need to implement those services you don’t need!</p>
</div>

<p>Weld registers resource injection points with <code class="literal">EjbInjectionServices</code>,
<code class="literal">JpaInjectionServices</code>, <code class="literal">ResourceInjectionServices</code> and
<code class="literal">JaxwsInjectionServices</code> implementations upfront (at bootstrap). This
allows validation of resource injection points to be performed at boot
time rather than runtime. For each resource injection point Weld obtains
a <code class="literal">ResourceReferenceFactory</code> which it then uses at runtime for creating
resource references.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ResourceReferenceFactory</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_plain">T</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">ResourceReference</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;createResource</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>A <code class="literal">ResourceReference</code> provides access to the resource reference to be
injected. Furthermore, <code class="literal">ResourceReference</code> allows resource to be release
once the bean that received resource injection is destroyed.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ResourceReference</span><!-- <br/> --><span class="java_operator">&lt;</span><!-- <br/> --><span class="java_plain">T</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;getInstance</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;release</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_ejb_services"/>A.1.4. EJB services</h3></div></div></div>

<p>EJB services are split between two interfaces which are both per-BDA.</p>
<p><code class="literal">EjbServices</code> is used to resolve local EJBs used to back session beans,
and must always be provided in an EE environment.
<code class="literal">EjbServices.resolveEjb(EjbDescriptor ejbDescriptor)</code> returns a
wrapper—<code class="literal">SessionObjectReference</code>—around the EJB reference. This wrapper
allows Weld to request a reference that implements the given business
interface, and, in the case of SFSBs, both request the removal of the
EJB from the container and query whether the EJB has been previously
removed.</p>
<p><code class="literal">EjbInjectionServices.registerEjbInjectionPoint(InjectionPoint injectionPoint)</code>
registers an <code class="literal">@EJB</code> injection point (on a managed bean) and returns a
<code class="literal">ResourceReferenceFactory</code> as explained above. This service is not
required if the implementation of &lt;&lt;_injection_services&gt; takes care of <code class="literal">@EJB</code> injection.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p><code class="literal">EJBInjectionServices.resolveEjb(InjectionPoint ij)</code>, which allows
<code class="literal">@EJB</code> injection point to be resolved without prior registration was
deprecated in Weld 2 and should no longer be used. An injection point
should be registered properly using
<code class="literal">EjbInjectionServices.registerEjbInjectionPoint(InjectionPoint injectionPoint)</code>
instead.</p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_jpa_services"/>A.1.5. JPA services</h3></div></div></div>

<p>Just as EJB resolution is delegated to the container, resolution of
<code class="literal">@PersistenceContext</code> for injection into managed beans (with the
<code class="literal">InjectionPoint</code> provided), is delegated to the container.</p>
<p>To allow JPA integration, the <code class="literal">JpaServices</code> interface should be
implemented. This service is not required if the implementation of <a href="_integrating_weld_into_other_environments.html#_injection_services" title="A.1.9. Injection Services">Section A.1.9, “Injection Services”</a>
takes care of <code class="literal">@PersistenceContext</code> injection.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>The following methods were deprecated in Weld 2:</p>
<p>*
<code class="literal">JpaInjectionServices.resolvePersistenceContext(InjectionPoint injectionPoint)</code>
*
<code class="literal">JpaInjectionServices.resolvePersistenceUnit(InjectionPoint injectionPoint)</code></p>
<p>An injection point should instead be registered properly using the
following methods:</p>
<p>*
<code class="literal">JpaInjectionServices.registerPersistenceContextInjectionPoint(InjectionPoint injectionPoint)</code>
*
<code class="literal">JpaInjectionServices.registerPersistenceUnitInjectionPoint(InjectionPoint injectionPoint)</code></p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_transaction_services"/>A.1.6. Transaction Services</h3></div></div></div>

<p>Weld delegates JTA activities to the container. The SPI provides a
couple hooks to easily achieve this with the <code class="literal">TransactionServices</code>
interface.</p>
<p>Any <code class="literal">javax.transaction.Synchronization</code> implementation may be passed to
the <code class="literal">registerSynchronization()</code> method and the SPI implementation should
immediately register the synchronization with the JTA transaction
manager used for the EJBs.</p>
<p>To make it easier to determine whether or not a transaction is currently
active for the requesting thread, the <code class="literal">isTransactionActive()</code> method can
be used. The SPI implementation should query the same JTA transaction
manager used for the EJBs.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_resource_services"/>A.1.7. Resource Services</h3></div></div></div>

<p>The resolution of <code class="literal">@Resource</code> (for injection into managed beans) is
delegated to the container. You must provide an implementation of
<code class="literal">ResourceInjectionServices</code> which provides these operations. This
service is not required if the implementation of <a href="_integrating_weld_into_other_environments.html#_injection_services" title="A.1.9. Injection Services">Section A.1.9, “Injection Services”</a> takes care of
<code class="literal">@Resource</code> injection.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>The following methods were deprecated in Weld 2:</p>
<p>*
<code class="literal">ResourceInjectionServices.resolveResource(InjectionPoint injectionPoint)</code>
*
<code class="literal">ResourceInjectionServices.resolveResource(String jndiName, String mappedName)</code></p>
<p>An injection point should instead be registered properly using the
following methods:</p>
<p>*
<code class="literal">ResourceInjectionServices.registerResourceInjectionPoint(InjectionPoint injectionPoint)</code>
*
<code class="literal">ResourceInjectionServices.registerResourceInjectionPoint(String jndiName, String mappedName)</code></p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_web_service_injection_services"/>A.1.8. Web Service Injection Services</h3></div></div></div>

<p>The resolution of <code class="literal">@WebServiceRef</code> (for injection into managed beans) is
delegated to the container. An integrator must provide an implementation
of <code class="literal">JaxwsInjectionServices</code>. This service is not required if the
implementation of <a href="_integrating_weld_into_other_environments.html#_injection_services" title="A.1.9. Injection Services">Section A.1.9, “Injection Services”</a> takes care of <code class="literal">@WebServiceRef</code> injection.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_injection_services"/>A.1.9. Injection Services</h3></div></div></div>

<p>An integrator may wish to use <code class="literal">InjectionServices</code> to provide additional
field or method injection over-and-above that provided by Weld. An
integration into a Java EE environment may use <code class="literal">InjectionServices</code> to
provide EE resource injection for managed beans.</p>
<p><code class="literal">InjectionServices</code> provides a very simple contract, the
<code class="literal">InjectionServices.aroundInject(InjectionContext ic);</code> interceptor will
be called for every instance that CDI injects, whether it is a
contextual instance, or a non-contextual instance injected by
<code class="literal">InjectionTarget.inject()</code>.</p>
<p>The <code class="literal">InjectionContext</code> can be used to discover additional information
about the injection being performed, including the <code class="literal">target</code> being
injected. <code class="literal">ic.proceed()</code> should be called to perform CDI-style
injection, and call initializer methods.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_resource_injection_point_validation"/>A.1.9.1. Resource injection point validation</h4></div></div></div>

<p>For each</p>
<div class="itemizedlist"><ul><li>
@Resource injection point
</li><li>
@PersistenceContext injection point
</li><li>
@PersistenceUnit injection point
</li><li>
@EJB injection point
</li><li>
@WebServiceRef injection point
</li></ul></div>

<p>Weld calls the <code class="literal">InjectionServices.registerInjectionTarget()</code> method.
That allows the integrator to validate resource injection points before
the application is deployed.</p>
</div>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_security_services"/>A.1.10. Security Services</h3></div></div></div>

<p>In order to obtain the <code class="literal">Principal</code> representing the current caller
identity, the container should provide an implementation of
<code class="literal">SecurityServices</code>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_the_bean_store"/>A.1.11. The bean store</h3></div></div></div>

<p>Weld uses a map like structure to store bean instances -
<code class="literal">org.jboss.weld.context.beanstore.BeanStore</code>. You may find
<code class="literal">org.jboss.weld.context.beanstore.ConcurrentHashMapBeanStore</code> useful.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">BeanStore</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;</span><span class="java_type">ContextualInstance</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;get</span><span class="java_separator">(</span><span class="java_type">BeanIdentifier</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;clear</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Iterator</span><span class="java_operator">&lt;</span><span class="java_type">BeanIdentifier</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;iterator</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;contains</span><span class="java_separator">(</span><span class="java_type">BeanIdentifier</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;put</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">ContextualInstance</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;contextualInstance</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;</span><span class="java_type">ContextualInstance</span><span class="java_operator">&lt;</span><span class="java_plain">T</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;remove</span><span class="java_separator">(</span><span class="java_type">BeanIdentifier</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_the_application_context"/>A.1.12. The application context</h3></div></div></div>

<p>Weld expects the Application Server or other container to provide the
storage for each application’s context. The
<code class="literal">org.jboss.weld.context.beanstore.BeanStore</code> should be implemented to
provide an application scoped storage.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_initialization_and_shutdown"/>A.1.13. Initialization and shutdown</h3></div></div></div>

<p>The <code class="literal">org.jboss.weld.bootstrap.api.Bootstrap</code> interface defines the
initialization for Weld, bean deployment and bean validation. To boot
Weld, you must create an instance of
<code class="literal">org.jboss.weld.bootstrap.WeldBeansBootstrap</code> (which implements
<code class="literal">Bootstrap</code>), tell it about the services in use, and then request the
container start.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Bootstrap</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Bootstrap</span><span class="java_plain">&nbsp;startContainer</span><span class="java_separator">(</span><span class="java_type">Environment</span><span class="java_plain">&nbsp;environment</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Deployment</span><span class="java_plain">&nbsp;deployment</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Bootstrap</span><span class="java_plain">&nbsp;startInitialization</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Bootstrap</span><span class="java_plain">&nbsp;deployBeans</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Bootstrap</span><span class="java_plain">&nbsp;validateBeans</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Bootstrap</span><span class="java_plain">&nbsp;endInitialization</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;shutdown</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">WeldManager</span><span class="java_plain">&nbsp;getManager</span><span class="java_separator">(</span><span class="java_type">BeanDeploymentArchive</span><span class="java_plain">&nbsp;beanDeploymentArchive</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BeansXml</span><span class="java_plain">&nbsp;parse</span><span class="java_separator">(</span><span class="java_plain">URL&nbsp;url</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BeansXml</span><span class="java_plain">&nbsp;parse</span><span class="java_separator">(</span><span class="java_type">Iterable</span><span class="java_operator">&lt;</span><span class="java_plain">URL</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;urls</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BeansXml</span><span class="java_plain">&nbsp;parse</span><span class="java_separator">(</span><span class="java_type">Iterable</span><span class="java_operator">&lt;</span><span class="java_plain">URL</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;urls</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;removeDuplicates</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Iterable</span><span class="java_operator">&lt;</span><span class="java_type">Metadata</span><span class="java_operator">&lt;</span><span class="java_type">Extension</span><span class="java_operator">&gt;&gt;</span><span class="java_plain">&nbsp;loadExtensions</span><span class="java_separator">(</span><span class="java_type">ClassLoader</span><span class="java_plain">&nbsp;classLoader</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<p>The bootstrap is split into phases, container initialization, bean
deployment, bean validation and shutdown. Initialization will create a
manager, and add the built-in contexts, and examine the deployment
structure. Bean deployment will deploy any beans (defined using
annotations, programmatically, or built in). Bean validation will
validate all beans.</p>
<p>To initialize the container, you call <code class="literal">Bootstrap.startInitialization()</code>.
Before calling <code class="literal">startInitialization()</code>, you must register any services
required by the environment. You can do this by calling, for example,
<code class="literal">bootstrap.getManager().getServices().add(JpaServices.class, new
            MyJpaServices())</code>. You must also provide the application
context bean store.</p>
<p>Having called <code class="literal">startInitialization()</code>, the <code class="literal">Manager</code> for each BDA can be
obtained by calling <code class="literal">Bootstrap.getManager(BeanDeploymentArchive bda)</code>.</p>
<p>To deploy the discovered beans, call <code class="literal">Bootstrap.deployBeans()</code>.</p>
<p>To validate the deployed beans, call <code class="literal">Bootstrap.validateBeans()</code>.</p>
<p>To place the container into a state where it can service requests, call
<code class="literal">Bootstrap.endInitialization()</code></p>
<p>To shutdown the container you call <code class="literal">Bootstrap.shutdown()</code>. This allows
the container to perform any cleanup operations needed.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_resource_loading"/>A.1.14. Resource loading</h3></div></div></div>

<p>Weld needs to load classes and resources from the classpath at various
times. By default, they are loaded from the Thread Context ClassLoader
if available, if not the same classloader that was used to load Weld,
however this may not be correct for some environments. If this is case,
you can implement <code class="literal">org.jboss.weld.resources.spi.ResourceLoader</code>.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">import</span><!-- <br/> --><span class="java_plain">&nbsp;org</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">jboss</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">weld</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">bootstrap</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">api</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_type">Service</span><!-- <br/> --><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">interface</span><span class="java_plain">&nbsp;</span><span class="java_type">ResourceLoader</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Service</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Class</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;classForName</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;name</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;URL&nbsp;getResource</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;name</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Collection</span><span class="java_operator">&lt;</span><span class="java_plain">URL</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getResources</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;name</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_annotationdiscovery"/>A.1.15. AnnotationDiscovery</h3></div></div></div>

<p>The optional <code class="literal">AnnotationDiscovery</code> service has been deprecated and is
not used by Weld since Weld 2.2. Integrators are encouraged to implement
<code class="literal">ClassFileServices</code> instead.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_classfileservices"/>A.1.16. ClassFileServices</h3></div></div></div>

<p>Integrators with bytecode-scanning capabilities may implement an
optional <code class="literal">ClassFileServices</code> service.</p>
<p>Bytecode-scanning is used by some application servers to speed up
deployment. Compared to loading a class using <code class="literal">ClassLoader</code>,
bytecode-scanning allows to obtain only a subset of the Java class file
metadata (e.g. annotations, class hierarchy, etc.) which is usually
loaded much faster. This allows the container to scan all classes
initially by a bytecode scanner and then use this limited information to
decide which classes need to be fully loaded using <code class="literal">ClassLoader</code>.
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://github.com/wildfly/jandex">Jandex</a> is an example of a
bytecode-scanning utility.</p>
<p><code class="literal">ClassFileServices</code> may be used by an integrator to provide container’s
bytecode-scanning capabilities to Weld. If present, Weld will try to use
the service to avoid loading of classes that do not need to be loaded.
These are classes that:</p>
<div class="itemizedlist"><ul><li>
are not <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/cdi/spec/1.1/cdi-spec.html#what_classes_are_beans">CDI managed beans</a> and
</li><li>
are not assignable to any ProcessAnnotatedType observer
</li></ul></div>

<p>This usually yields improved bootstrap performance especially in large
deployments with a lot of classes in explicit bean archives.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ClassFileServices</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">extends</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">BootstrapService</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">ClassFileInfo</span><span class="java_plain">&nbsp;getClassFileInfo</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;className</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre>

<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ClassFileInfo</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;getClassName</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;getSuperclassName</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isAnnotationDeclared</span><span class="java_separator">(</span><span class="java_type">Class</span><span class="java_operator">&lt;?</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Annotation</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;annotationType</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;containsAnnotation</span><span class="java_separator">(</span><span class="java_type">Class</span><span class="java_operator">&lt;?</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Annotation</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;annotationType</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;getModifiers</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;hasCdiConstructor</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isAssignableFrom</span><span class="java_separator">(</span><span class="java_type">Class</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;javaClass</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isAssignableTo</span><span class="java_separator">(</span><span class="java_type">Class</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;javaClass</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isVetoed</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isTopLevelClass</span><span class="java_separator">();</span></pre>

<p>See the JavaDoc for more details.</p>
</div>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_the_contract_with_the_container"/>A.2. The contract with the container</h2></div></div></div>

<p>There are a number of requirements that Weld places on the container for
correct functioning that fall outside implementation of APIs.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_classloader_isolation"/>A.2.1. Classloader isolation</h3></div></div></div>

<p>If you are integrating Weld into an environment that supports deployment
of multiple applications, you must enable, automatically, or through
user configuration, classloader isolation for each CDI application.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_servlet"/>A.2.2. Servlet</h3></div></div></div>

<p>If you are integrating Weld into a Servlet environment you must register
<code class="literal">org.jboss.weld.servlet.WeldInitialListener</code> and
<code class="literal">org.jboss.weld.servlet.WeldTerminalListener</code> as Servlet listeners,
either automatically, or through user configuration, for each CDI
application which uses Servlet.</p>
<p>You must ensure that <code class="literal">WeldListener</code> is called before any other
application-defined listener is called and that <code class="literal">WeldTerminalListener</code>
is called only after all application-defined listeners have been called.</p>
<p>You must ensure that <code class="literal">WeldListener.contextInitialized()</code> is called after
beans are deployed is complete (<code class="literal">Bootstrap.deployBeans()</code> has been
called).</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_cdi_conversation_filter_2"/>A.2.3. CDI Conversation Filter</h3></div></div></div>

<p>A CDI implementation is required to provide a Servlet filter named “CDI
Conversation Filter”. The filter may be mapped by an application in the
web descriptor. That allows application to place another filter around
the CDI filter for dealing with exceptions.</p>
<p>Weld provides this filter with a fully qualified class name
of`org.jboss.weld.servlet.ConversationFilter`.</p>
<p>If the application contains a filter mapping for a filter named “CDI
Conversation Filter”, the integrator is required to register
<code class="literal">org.jboss.weld.servlet.ConversationFilter</code> as a filter with “CDI
Conversation Filter” as its filter name. If no such mapping exists in
the application, the integrator is not required to register the filter.
In that case, WeldListener will take care of conversation context
activation/deactivation at the beginning of HTTP request processing.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_jsf"/>A.2.4. JSF</h3></div></div></div>

<p>If you are integrating Weld into a JSF environment you must register
<code class="literal">org.jboss.weld.el.WeldELContextListener</code> as an EL Context listener.</p>
<p>If you are integrating Weld into a JSF environment you must register
<code class="literal">org.jboss.weld.jsf.ConversationAwareViewHandler</code> as a delegating view
handler.</p>
<p>If you are integrating Weld into a JSF environment you must obtain the
bean manager for the module and then call
<code class="literal">BeanManager.wrapExpressionFactory()</code>, passing
<code class="literal">Application.getExpressionFactory()</code> as the argument. The wrapped
expression factory must be used in all EL expression evaluations
performed by JSF in this web application.</p>
<p>If you are integrating Weld into a JSF environment you must obtain the
bean manager for the module and then call <code class="literal">BeanManager.getELResolver()</code>,
The returned EL resolver should be registered with JSF for this web
application.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2>
<p>There are a number of ways you can obtain the bean manager for the
module. You could call <code class="literal">Bootstrap.getManager()</code>, passing in the BDA for
this module. Alternatively, you could use the injection into Java EE
component classes, or look up the bean manager in JNDI.</p>
</div>

<p>If you are integrating Weld into a JSF environment you must register
<code class="literal">org.jboss.weld.servlet.ConversationPropagationFilter</code> as a Servlet
listener, either automatically, or through user configuration, for each
CDI application which uses JSF. This filter can be registered for all
Servlet deployment safely.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p>Weld only supports JSF 1.2 and above.</p>
</div>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p><code class="literal">org.jboss.weld.jsf.WeldPhaseListener</code> was deprecated in Weld 2 and is
no longer present in Weld.</p>
</div>

<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
<p><code class="literal">org.jboss.weld.servlet.ConversationPropagationFilter</code> was deprecated
and should no longer be used.</p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_jsp"/>A.2.5. JSP</h3></div></div></div>

<p>If you are integrating Weld into a JSP environment you must register
<code class="literal">org.jboss.weld.el.WeldELContextListener</code> as an EL Context listener.</p>
<p>If you are integrating Weld into a JSP environment you must obtain the
bean manager for the module and then call
<code class="literal">BeanManager.wrapExpressionFactory()</code>, passing
<code class="literal">Application.getExpressionFactory()</code> as the argument. The wrapped
expression factory must be used in all EL expression evaluations
performed by JSP.</p>
<p>If you are integrating Weld into a JSP environment you must obtain the
bean manager for the module and then call <code class="literal">BeanManager.getELResolver()</code>,
The returned EL resolver should be registered with JSP for this web
application.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2>
<p>There are a number of ways you can obtain the bean manager for the
module. You could call <code class="literal">Bootstrap.getManager()</code>, passing in the BDA for
this module. Alternatively, you could use the injection into Java EE
component classes, or look up the bean manager in JNDI.</p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_session_bean_interceptor"/>A.2.6. Session Bean Interceptor</h3></div></div></div>

<p><code class="literal">org.jboss.weld.ejb.SessionBeanInterceptor</code> takes care of activating the
request scope around EJB method invocations in a non-servlet
environment, such as message-driven bean invocation, <code class="literal">@Asynchronous</code>
invocation or <code class="literal">@Timeout</code>. If you are integrating Weld into an EJB
environment you must register the <code class="literal">aroundInvoke</code> method of
<code class="literal">SessionBeanInterceptor</code> as a EJB around-invoke interceptor for all EJBs
in the application, either automatically, or through user configuration,
for each CDI application which uses enterprise beans.</p>
<p>If you are running in a EJB 3.2 environment, you should register this as
an around-timeout interceptor as well.</p>
<p>In addition, since CDI 1.1 the <code class="literal">aroundInvoke</code> method of
<code class="literal">SessionBeanInterceptor</code> should be invoked around <code class="literal">@PostConstruct</code>
callbacks of EJBs.</p>
<div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2>
<p>You must register the <code class="literal">SessionBeanInterceptor</code> as the inner most
interceptor in the stack for all EJBs.</p>
</div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_the_literal_weld_core_jar_literal"/>A.2.7. The <code class="literal">weld-core.jar</code></h3></div></div></div>

<p>Weld can reside on an isolated classloader, or on a shared classloader.
If you choose to use an isolated classloader, the default
<code class="literal">SingletonProvider</code>, <code class="literal">IsolatedStaticSingletonProvider</code>, can be used. If
you choose to use a shared classloader, then you will need to choose
another strategy.</p>
<p>You can provide your own implementation of <code class="literal">Singleton</code> and
<code class="literal">SingletonProvider</code> and register it for use using
<code class="literal">SingletonProvider.initialize(SingletonProvider provider)</code>.</p>
<p>Weld also provides an implementation of Thread Context Classloader per
application strategy, via the <code class="literal">TCCLSingletonProvider</code>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_binding_the_manager_in_jndi"/>A.2.8. Binding the manager in JNDI</h3></div></div></div>

<p>You should bind the bean manager for the bean deployment archive into
JNDI at <code class="literal">java:comp/BeanManager</code>. The type should be
<code class="literal">javax.enterprise.inject.spi.BeanManager</code>. To obtain the correct bean
manager for the bean deployment archive, you may call
<code class="literal">bootstrap.getBeanManager(beanDeploymentArchive)</code></p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_cdiprovider_literal"/>A.2.9. <code class="literal">CDIProvider</code></h3></div></div></div>

<p>CDI 1.1 provides a simplified approach to accessing the BeanManager /
CDI container from components that do not support injection. This is
done by the CDI class API. The integrating part can either use
<code class="literal">org.jboss.weld.AbstractCDI</code> or <code class="literal">org.jboss.weld.SimpleCDI</code> provided by
Weld core and register it using
<code class="literal">javax.enterprise.inject.spi.CDIProvider</code> file that is visible to the
CDI API classes or use the <code class="literal">CDI.setCDIProvider(CDIProvider provider)</code>
method method early in the deployment.</p>
<p>Alternatively, an integrating part may provide a specialized
implementation such as the one provided by
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://github.com/wildfly/wildfly/blob/master/weld/src/main/java/org/jboss/as/weld/WeldProvider.java">WildFly
integration</a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_performing_cdi_injection_on_java_ee_component_classes"/>A.2.10. Performing CDI injection on Java EE component classes</h3></div></div></div>

<p>The CDI specification requires the container to provide injection into
non-contextual resources for all Java EE component classes. Weld
delegates this responsibility to the container. This can be achieved
using the CDI defined <code class="literal">InjectionTarget</code> SPI. Furthermore, you must
perform this operation on the correct bean manager for the bean
deployment archive containing the EE component class.</p>
<p>The CDI specification also requires that a <code class="literal">ProcessInjectionTarget</code>
event is fired for every Java EE component class. Furthermore, if an
observer calls <code class="literal">ProcessInjectionTarget.setInjectionTarget()</code> the
container must use <span class="emphasis"><em>the specified</em></span> injection target to perform
injection.</p>
<p>To help the integrator, Weld provides
<code class="literal">WeldManager.fireProcessInjectionTarget()</code> which returns the
<code class="literal">InjectionTarget</code> to use.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Fire</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ProcessInjectionTarget</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;returning&nbsp;the&nbsp;</span><!-- <br/> --><span class="java_type">InjectionTarget</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;to&nbsp;use</span>
<!--  --><br/><span class="java_type">InjectionTarget</span><span class="java_plain">&nbsp;it&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;weldBeanManager</span><span class="java_separator">.</span><span class="java_plain">fireProcessInjectionTarget</span><span class="java_separator">(</span><span class="java_plain">clazz</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Per</span><span class="java_plain">&nbsp;instance&nbsp;required</span><span class="java_separator">,</span><span class="java_plain">&nbsp;create&nbsp;the&nbsp;creational&nbsp;context</span>
<!--  --><br/><span class="java_type">CreationalContext</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;cc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;beanManager</span><span class="java_separator">.</span><span class="java_plain">createCreationalContext</span><span class="java_separator">(</span><span class="java_literal">null</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Produce</span><span class="java_plain">&nbsp;the&nbsp;instance</span><span class="java_separator">,</span><span class="java_plain">&nbsp;performing&nbsp;any&nbsp;constructor&nbsp;injection&nbsp;required</span>
<!--  --><br/><span class="java_type">Object</span><span class="java_plain">&nbsp;instance&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;it</span><span class="java_separator">.</span><span class="java_plain">produce</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Perform</span><span class="java_plain">&nbsp;injection&nbsp;and&nbsp;call&nbsp;initializers</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">inject</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">,</span><span class="java_plain">&nbsp;cc</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Call</span><span class="java_plain">&nbsp;the&nbsp;post</span><span class="java_operator">-</span><span class="java_plain">construct&nbsp;callback</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">postConstruct</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Call</span><span class="java_plain">&nbsp;the&nbsp;pre</span><span class="java_operator">-</span><span class="java_plain">destroy&nbsp;callback</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">preDestroy</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Clean</span><span class="java_plain">&nbsp;up&nbsp;the&nbsp;instance</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">dispose</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">cc</span><span class="java_separator">.</span><span class="java_plain">release</span><span class="java_separator">();</span></pre>

<p>The container may intersperse other operations between these calls.
Further, the integrator may choose to implement any of these calls in
another manner, assuming the contract is fulfilled.</p>
<p>When performing injections on EJBs you must use the Weld-defined SPI,
<code class="literal">WeldManager</code>. Furthermore, you must perform this operation on the
correct bean manager for the bean deployment archive containing the EJB.</p>
<pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Obtain</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;</span><!-- <br/> --><span class="java_type">EjbDescriptor</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;EJB</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">You</span><span class="java_plain">&nbsp;may&nbsp;choose&nbsp;to&nbsp;use&nbsp;</span><span class="java_keyword">this</span><span class="java_plain">&nbsp;utility&nbsp;method&nbsp;to&nbsp;get&nbsp;the&nbsp;descriptor</span>
<!--  --><br/><span class="java_type">EjbDescriptor</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;ejbDescriptor&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;beanManager</span><span class="java_separator">.</span><span class="java_plain">getEjbDescriptor</span><span class="java_separator">(</span><span class="java_plain">ejbName</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Get</span><span class="java_plain">&nbsp;an&nbsp;the&nbsp;</span><span class="java_type">Bean</span><span class="java_plain">&nbsp;object</span>
<!--  --><br/><span class="java_type">Bean</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;bean&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;beanManager</span><span class="java_separator">.</span><span class="java_plain">getBean</span><span class="java_separator">(</span><span class="java_plain">ejbDescriptor</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Create</span><span class="java_plain">&nbsp;the&nbsp;injection&nbsp;target</span>
<!--  --><br/><span class="java_type">InjectionTarget</span><span class="java_plain">&nbsp;it&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;deploymentBeanManager</span><span class="java_separator">.</span><span class="java_plain">createInjectionTarget</span><span class="java_separator">(</span><span class="java_plain">ejbDescriptor</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Per</span><span class="java_plain">&nbsp;instance&nbsp;required</span><span class="java_separator">,</span><span class="java_plain">&nbsp;create&nbsp;the&nbsp;creational&nbsp;context</span>
<!--  --><br/><span class="java_type">CreationalContext</span><span class="java_operator">&lt;?&gt;</span><span class="java_plain">&nbsp;cc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;deploymentBeanManager</span><span class="java_separator">.</span><span class="java_plain">createCreationalContext</span><span class="java_separator">(</span><span class="java_plain">bean</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Perform</span><span class="java_plain">&nbsp;injection&nbsp;and&nbsp;call&nbsp;initializers</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">inject</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">,</span><span class="java_plain">&nbsp;cc</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">You</span><span class="java_plain">&nbsp;may&nbsp;choose&nbsp;to&nbsp;have&nbsp;CDI&nbsp;call&nbsp;the&nbsp;post&nbsp;construct&nbsp;and&nbsp;pre&nbsp;destroy</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;lifecycle&nbsp;callbacks</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Call</span><span class="java_plain">&nbsp;the&nbsp;post</span><span class="java_operator">-</span><span class="java_plain">construct&nbsp;callback</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">postConstruct</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Call</span><span class="java_plain">&nbsp;the&nbsp;pre</span><span class="java_operator">-</span><span class="java_plain">destroy&nbsp;callback</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">preDestroy</span><span class="java_separator">(</span><span class="java_plain">instance</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Clean</span><span class="java_plain">&nbsp;up&nbsp;the&nbsp;instance</span>
<!--  --><br/><span class="java_plain">it</span><span class="java_separator">.</span><span class="java_plain">dispose</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">cc</span><span class="java_separator">.</span><span class="java_plain">release</span><span class="java_separator">();</span></pre>

</div>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_migration_notes"/>A.3. Migration notes</h2></div></div></div>

<p>This part of the appendix documents the changes in Weld across major and
minor releases that an integrator should be aware of. These changes
mostly touch changes in the SPI or in the container contract.</p>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_migration_from_weld_1_x_to_2_0"/>A.3.1. Migration from Weld 1.x to 2.0</h3></div></div></div>

<p>All the changes are documented in this external
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://community.jboss.org/wiki/WeldIntegratorGuide-ChangesForWeld20">migration
document</a>.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_migration_from_weld_2_0_to_2_1"/>A.3.2. Migration from Weld 2.0 to 2.1</h3></div></div></div>

<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_logging"/>A.3.2.1. Logging</h4></div></div></div>

<p>Weld no longer uses <code class="literal">slf4j</code> for logging. Instead,
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://search.maven.org/#search%7Cga%7C1%7Cjboss-logging">jboss-logging</a>
is now used as a logging facade.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_httpcontextactivationfilter"/>A.3.2.2. HttpContextActivationFilter</h4></div></div></div>

<p>A new service named
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.1/weld-spi/org/jboss/weld/servlet/spi/HttpContextActivationFilter.html">HttpContextActivationFilter</a>
was added to the Weld SPI. This optional service allows an integrator to
decide if CDI contexts should be activated or not for a given HTTP
request. By default, CDI contexts are always active but this hook allows
an integrator to eliminate the overhead of CDI context activation for
certain types of requests where CDI is known not to be needed (e.g.
request for a static resource).</p>
<p>Note that when the service is provided, <a xmlns:xlink="http://www.w3.org/1999/xlink" href="#context.mapping">user
configuration</a> is overriden.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_non_portable_mode"/>A.3.2.3. Non-portable mode</h4></div></div></div>

<p>The
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.1/weld-spi/org/jboss/weld/bootstrap/spi/BootstrapConfiguration.html#isNonPortableModeEnabled%28%29">BootstrapConfiguration</a>
service now allows the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="#non-portable.mode">non-portable mode</a> to be
enabled by the integrator.</p>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_singleton_spi"/>A.3.2.4. Singleton SPI</h4></div></div></div>

<p>Since Weld 2.1 the
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.1/weld-spi/org/jboss/weld/bootstrap/api/Singleton.html">Singleton
SPI</a> requires the singleton to be identified by a String <code class="literal">context id</code>.
This allows multiple Weld containers to run at the same time in
environments where the TCCL cannot be used to distinguish the containers
(e.g. OSGi environment).</p>
<p>The integrator should:</p>
<div class="itemizedlist"><ul><li>
implement the new methods
</li><li>
use WeldBootstrap.startContainer(String contextId, Environment environment,
Deployment deployment) to start Weld
</li><li>
eliminate all Container.instance() calls and replace them with Container.instance(String contextId)
</li></ul></div>

</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="_weld_osgi_bundle"/>A.3.2.5. Weld-OSGi bundle</h4></div></div></div>

<p>The Weld-OSGi bundle does no include Weld’s runtime dependencies
anymore. Therefore, it is possible to deploy the following artifacts in
order to satisfy Weld’s dependencies:</p>
<div class="informaltable">
  
  <table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="left" valign="top">group id</th><th align="left" valign="top">artifact id</th><th align="left" valign="top">version</th></tr></thead><tbody><tr><td align="left" valign="top"><p>org.jboss.logging</p></td><td align="left" valign="top"><p>jboss-logging</p></td><td align="left" valign="top"><p>3.1.3.GA</p></td></tr><tr><td align="left" valign="top"><p>com.google.guava</p></td><td align="left" valign="top"><p>guava</p></td><td align="left" valign="top"><p>13.0.1</p></td></tr><tr><td align="left" valign="top"><p>javax.enterprise</p></td><td align="left" valign="top"><p>cdi-api</p></td><td align="left" valign="top"><p>1.1-20130918</p></td></tr><tr><td align="left" valign="top"><p>javax.annotation</p></td><td align="left" valign="top"><p>javax.annotation-api</p></td><td align="left" valign="top"><p>1.2</p></td></tr><tr><td align="left" valign="top"><p>javax.interceptor</p></td><td align="left" valign="top"><p>javax.interceptor-api</p></td><td align="left" valign="top"><p>1.2</p></td></tr><tr><td align="left" valign="top"><p>org.apache.geronimo.specs</p></td><td align="left" valign="top"><p>geronimo-el_2.2_spec</p></td><td align="left" valign="top"><p>1.0.3</p></td></tr></tbody></table>
</div>

</div>
</div>
<div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_migration_from_weld_2_1_to_2_2"/>A.3.3. Migration from Weld 2.1 to 2.2</h3></div></div></div>

<div class="itemizedlist"><ul><li>
The definition of a <span class="emphasis"><em>bean defining annotation</em></span> was altered in CDI 1.2.
See the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://cdi-spec.org">specification</a> for more information.
</li><li>
A new
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.2/weld-spi/org/jboss/weld/manager/api/WeldInjectionTargetBuilder.html"><code class="literal">WeldInjectionTargetBuilder</code></a>
SPI was added. The SPI allows an integrator to obtain a customized
<code class="literal">InjectionTarget</code> implementation using the builder pattern.
</li><li>
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#annotationDiscovery">The AnnotationDiscovery service</a> was
deprecated in favor of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="#classFileServices">ClassFileServices</a> .
*
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.2/weld-spi/org/jboss/weld/bootstrap/api/CDI11Bootstrap.html#startContainer(java.lang.String">http://docs.jboss.org/weld/javadoc/2.2/weld-spi/org/jboss/weld/bootstrap/api/CDI11Bootstrap.html#startContainer(java.lang.String</a>, org.jboss.weld.bootstrap.api.Environment, org.jboss.weld.bootstrap.spi.Deployment)[<code class="literal">CDIBootstrap.startContainer()</code>]
method, which allows a container identifier to be passed as a parameter,
was added.
</li><li>
The contract of the
<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/javadoc/2.2/weld-spi/org/jboss/weld/ejb/api/SessionObjectReference.html#getBusinessObject(java.lang.Class)"><code class="literal">SessionObjectReference.getBusinessObject()</code></a> method was altered. Weld may now call
this method passing in a remote view of a session bean.
</li><li>
The <a xmlns:xlink="http://www.w3.org/1999/xlink" href="#cdiProvider">CDI provider implementation</a> was reimplemented
and is no longer compatible with the previous version.
</li></ul></div>

</div>
</div>
</div><ul class="docnav"><li class="previous"><a accesskey="p" href="_configuration.html"><strong>Prev</strong>Chapter 20. Configuration</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li></ul></body></html>